archetype nonfungible

asset token {
  tid        : nat;
  tprice     : tez;
}

asset ledger identified by ltoken {
  ltoken     : nat;
  lowner     : address;
}

asset allowance identified by atoken {
  atoken     : nat;
  aoperator  : address;
}

entry approve (spender : address, tokenid : nat) {
  require {
    r1 otherwise "NOT_OWNER": ledger[tokenid].lowner = caller
  }
  effect {
    allowance.add({tokenid; spender});
  }
}

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
}

entry %transfer (%from : address, tds : list<transfer_destination>) {
  for td in tds do begin
    if caller <> %from then begin
      // check allowance
      dorequire(allowance[td.token_id_dest].aoperator = caller, "NOT_ALLOWED");
    end;
    // set token ownership
    ledger.addupdate(td.token_id_dest,{ lowner = td.to_dest });
  end done;
}

entry buy (tokenids : list<nat>) {
  var total = 0;
  for tokenid in tokenids do begin
    var price = token[tokenid].tprice;
    var owner = ledger[tokenid].lowner;
    transfer price to owner;
    transfer 0tz to entry self.%transfer(owner,[{ to_dest = caller; token_id_dest = tokenid; token_amount_dest = 1 }]);
    total += price;
  end done;
  dorequire(transferred >= total, "INSUFFICIENT_TRANSFERRED");
}

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
}

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
}

getter balance_of (brs : list<balance_of_request>) : list<balance_of_response> {
  return map(brs, br -> {
    request = br;
    balance_ = (if ledger[br.btoken_id] = br.bo_owner
                then 1
                else 0)
  })
}