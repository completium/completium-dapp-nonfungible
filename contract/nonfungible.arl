archetype nonfungible

asset token {
  tid        : nat;
  tprice     : tez;
}

asset ledger identified by ltoken {
  ltoken     : nat;
  lowner     : address;
}

asset operator identified by oaddr otoken oowner {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
}

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
}

entry update_operators (upl : list<or<operator_param, operator_param>>) {
  for up in upl do
    match_or up with
    | left(param) -> // add
      operator.addupdate((param.opp_operator, param.opp_token_id, param.opp_owner), {})
    | right(param) -> // remove
      operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
    end;
  done;
}

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
}

entry %transfer (%from : address, tds : list<transfer_destination>) {
  for td in tds do begin
    if caller <> %from then begin
      // check operator
      dorequire(operator.contains((caller,td.token_id_dest,%from)),"OPERATOR_NOT_ALLOWED");
    end;
    // set token ownership
    ledger.addupdate(td.token_id_dest,{ lowner = td.to_dest });
  end done;
}

entry buy (tokenids : list<nat>) {
  var total = 0;
  for tokenid in tokenids do begin
    var price = token[tokenid].tprice;
    var owner = ledger[tokenid].lowner;
    transfer price to owner;
    transfer 0tz to entry self.update_operators([right<operator_param>({
        opp_owner = owner;
        opp_operator = caller;
        opp_token_id = tokenid
      })]);
    transfer 0tz to entry self.%transfer(owner,[{
      to_dest = caller;
      token_id_dest = tokenid;
      token_amount_dest = 1
    }]);
    total += price;
  end done;
  dorequire(transferred >= total, "INSUFFICIENT_TRANSFERRED");
}

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
}

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
}

getter balance_of (brs : list<balance_of_request>) : list<balance_of_response> {
  return map(brs, br -> {
    request = br;
    balance_ = (if ledger[br.btoken_id].lowner = br.bo_owner
                then 1
                else 0)
  })
}
