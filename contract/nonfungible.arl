archetype nonfungible

/* STORAGE --------------------------------------------------------------------*/

asset token {
  tid        : nat;
  tprice     : tez;
} initialized by {
  { 973012;  1300mtz };
  { 973013;  2200mtz };
  { 973014;  1400mtz };
  { 973015;  3400mtz };
  { 973016;  2800mtz };
  { 973017;  1000mtz };
  { 973018;  2400mtz };
  { 973019;  4100mtz };
  { 973020; 12400mtz };
  { 973021; 18900mtz };
  { 973022;  1200mtz };
  { 973023;  2700mtz };
  { 973024;  4000mtz };
  { 973025;  1900mtz };
  { 973026;  3700mtz };
  { 973027;  4100mtz };
  { 973028;  2500mtz };
  { 973029;   400mtz };
  { 973030;  1900mtz };
  { 973031;   500mtz };
  { 973032;   400mtz };
  { 973033;   200mtz };
  { 973034;  7800mtz };
  { 973035;  5600mtz };
  { 973036;  5600mtz };
  { 973037;  5600mtz };
  { 973038;  5600mtz };
  { 973039;  7600mtz };
  { 973040;  5300mtz };
  { 973041;  5300mtz };
  { 973042;  1400mtz };
  { 973043;  8600mtz };
  { 973044;  4900mtz };
  { 973045;  5300mtz };
  { 973046;  9500mtz };
  { 973047;  7500mtz };
  { 973048;  8000mtz };
  { 973049;  7400mtz };
  { 973050;  6100mtz };
  { 973051;  5000mtz };
  { 973052;  3100mtz };
  { 973053;  6700mtz };
  { 973054;  8000mtz };
  { 973055;  4000mtz };
  { 973056;  4100mtz };
  { 973057;  3100mtz };
  { 973058; 12100mtz };
  { 973059;  4700mtz };
  { 973060;  3200mtz };
  { 973061;  4500mtz };
  { 973062;  3500mtz };
  { 973063;  3400mtz };
  { 973064;  5600mtz };
  { 973065;  3300mtz };
  { 973066;  3600mtz };
  { 973067;  3500mtz };
  { 973068;  3300mtz };
  { 973069;  4100mtz };
  { 973070;  3600mtz };
  { 973071;  3700mtz };
  { 973072;  3200mtz };
  { 973073;  5100mtz };
  { 973074; 12100mtz };
  { 973075;  9500mtz };
  { 973076; 14100mtz };
  { 973077; 10500mtz };
  { 973078; 11300mtz };
  { 973079; 10500mtz };
  { 973080; 10500mtz };
  { 973081;  4500mtz };
  { 973082; 10500mtz };
  { 973083; 13400mtz };
  { 973084; 17600mtz };
  { 973085; 27600mtz };
  { 973086; 39600mtz };
  { 973087; 42600mtz };
  { 973088; 34300mtz };
  { 973089; 28300mtz };
  { 973090; 44200mtz };
  { 973091; 26400mtz };
  { 973092; 24500mtz };
  { 973093; 23900mtz };
  { 973094; 14300mtz };
  { 973095; 12300mtz };
  { 973096; 11300mtz };
  { 973097;  6500mtz };
  { 973098;  4900mtz };
  { 973099;  8400mtz };
  { 973100;  4300mtz };
  { 973101;  4200mtz };
  { 973102;  4500mtz };
  { 973103; 12300mtz };
  { 973104; 15600mtz };
  { 973105;  4600mtz };
  { 973106;  5500mtz };
  { 973107;  4500mtz };
  { 973108;  2300mtz };
  { 973109;  4500mtz };
  { 973110;  4200mtz };
  { 973111;  3200mtz };
  { 973112;  2200mtz };
  { 973113;  1400mtz }
}

asset ledger identified by ltoken {
  ltoken     : nat;
  lowner     : address;
}

asset operator identified by oaddr otoken oowner {
  oaddr       : address;
  otoken      : nat;
  oowner      : address;
}

/* FA2 INTERFACE -------------------------------------------------------------*/

record operator_param {
  opp_owner    : address;
  opp_operator : address;
  opp_token_id : nat
} as ((owner, (operator, token_id)))

entry update_operators (upl : list<or<operator_param, operator_param>>) {
  for up in upl do
    match_or up with
    | left(param)  -> // add
      dorequire(ledger[param.opp_token_id].lowner = caller, "CALLER NOT OWNER");
      operator.addupdate((param.opp_operator, param.opp_token_id, param.opp_owner), {})
    | right(param) -> // remove
      dorequire(ledger[param.opp_token_id].lowner = caller, "CALLER NOT OWNER");
      operator.remove((param.opp_operator, param.opp_token_id, param.opp_owner))
    end;
  done;
}

record transfer_destination {
  to_dest           : address;
  token_id_dest     : nat;
  token_amount_dest : nat
} as ((to_, (token_id, amount)))

entry %transfer (txs : list<address * list<transfer_destination>>) {
  for tx in txs do
    var %from = tx[0];
    var tds = tx[1];
    for td in tds do begin
      if caller <> %from then begin
        // check operator
        dorequire(operator.contains((caller,td.token_id_dest,%from)),"FA2_NOT_OPERATOR");
      end;
      // set token ownership
      ledger.addupdate(td.token_id_dest,{ lowner = td.to_dest });
    end done;
  done
}

record balance_of_request {
  bo_owner : address;
  btoken_id : nat;
} as ((owner, token_id))

record balance_of_response {
  request : balance_of_request;
  balance_ : nat;
} as ((request, balance))

getter balance_of (requests : list<balance_of_request>) : list<balance_of_response> {
  return map(requests, br -> {
    request = br;
    balance_ = (if ledger[br.btoken_id].lowner = br.bo_owner
                then 1
                else 0)
  })
}

entry token_metadata_registry (c : contract<address>) { transfer 0tz to entry c(selfaddress); }

asset token_metadata to big_map {
  key_token_id   : nat;
  token_id       : nat;
  symbol         : string;
  name           : string;
  decimals       : nat;
  extras         : map<string, string>;
} initialized by {
  { 1; 1; "CRB"; "CRYPTOBOKEN"; 0; [] }
}

/* TOKEN EXCHANGE INTERFACE ---------------------------------------------------*/

entry buy (tokenids : list<nat>) {
  var total = 0;
  for tokenid in tokenids do begin
    var price = token[tokenid].tprice;
    var owner = ledger[tokenid].lowner;
    transfer price to owner;
    /* transfer ownership */
    transfer 0tz to entry self.%transfer([(owner,[{
      to_dest = caller;
      token_id_dest = tokenid;
      token_amount_dest = 1
    }])]);
    /* reset permission */
    transfer 0tz to entry self.update_operators([right<operator_param>({
        opp_owner = owner;
        opp_operator = caller;
        opp_token_id = tokenid
      })]);
    total += price;
  end done;
  dorequire(transferred >= total, "INSUFFICIENT_TRANSFERRED");
  operations := reverse(operations);
}

entry sell (tokenid : nat) {
  transfer 0tz to entry self.update_operators([left<operator_param>({
    opp_owner = caller;
    opp_operator = selfaddress;
    opp_token_id = tokenid
  })])
}


